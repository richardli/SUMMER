% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simSurvey.R
\name{simSurvey}
\alias{simSurvey}
\alias{getHHpop}
\alias{sampleClusterSurveys}
\alias{getClustpaFromSurvey}
\title{Simulate DHS-like surveys from EA- or HH-level population information}
\usage{
getHHpop(popSim, fixPopPerHH = NULL, verbose = TRUE)

sampleClusterSurveys(
  n = NULL,
  popSim = NULL,
  HHperClust = 25,
  fixPopPerHH = NULL,
  eaSampleStrat = c("pps", "srs"),
  clustpaList,
  seed = NULL,
  verbose = FALSE
)

getClustpaFromSurvey(
  survDat,
  stratName = "area",
  stratOrder = sort(unique(survDat[[stratName]])),
  nVarName = "N",
  nHHVarName = "nHH"
)
}
\arguments{
\item{popSim}{Simulated population. Must contain EA or HH level population information, i.e. 
either an element named 'eaPop' or 'eaSimDat' containing a list of 
populations simulated at the EA level. See \code{\link{simPopCustom}}}

\item{fixPopPerHH}{Currently only 1 or NULL is supported. If 1, fixes the target population 
to be 1 in each simulated household (requires EA populations and 
num households are equal). If NULL, randomly distributes population 
among the households (default)}

\item{verbose}{If TRUE, prints progress and all warnings}

\item{n}{Number of simulated surveys. NOTE: storing household level information can 
get quite memory intensive. Recommended to simulate 1 household level population and 1 
associated survey at a time.}

\item{HHperClust}{Fixed number of households per selected EA to include in the survey}

\item{eaSampleStrat}{EA level sampling strategy. Either 'pps' or 'srs'. If 'pps', samples 
EAs with probability proportional to the number of households in the EA. Within each sampled 
EA, households are always sampled via srs.}

\item{clustpaList}{a list of data.frame objects, 1 for each survey to sample, providing 
information on the number of clusters to sample per stratum. Should contain elements:
\describe{
  \item{area}{name of area}
  \item{EAUrb}{number of urban enumeration areas in the area}
  \item{EARur}{number of rural enumeration areas in the area}
}}

\item{seed}{If not NULL, the random number seed to set at the beginning of the function}

\item{survDat}{simulated survey from \code{sampleClusterSurveys}}

\item{stratName}{The name of the survey stratum variable to aggregate the number 
of clusters over. Defaults to 'area'.}

\item{stratOrder}{if provided, will sort resulting strata to be in the same order as in}

\item{nVarName}{variable name in the survey data.frame of the target population denominator}

\item{nHHVarName}{variance name in the survey data.frame of the number of households variable name}
}
\value{
The simulated survey data, household level population, or aggregated survey information from 
\code{sampleClusterSurveys}, \code{getHHpop}, and \code{getClustpaFromSurvey} respectively.
}
\description{
Given a spatial risk model, simulate populations and population prevalences at the 
enumeration area level (represented as points), and aggregate to the pixel and 
administrative areal level.
}
\details{
Functions for simulating multilevel household cluster surveys based on simulated populations 
from other SUMMER functions. For surveys with structures similar to the DHS or MICS. Information on 
spatial coordinates included. NOTE: storing household level information can 
get quite memory intensive. Recommended to simulate 1 household level population and 1 
associated survey at a time. Multiple surveys can be sampled from the same household level population
}
\section{Functions}{
\itemize{
\item \code{getHHpop()}: Simulates household level population data given EA level population data

\item \code{sampleClusterSurveys()}: Simulates household cluster surveys from input population with EA or HH level info

\item \code{getClustpaFromSurvey()}: Collects information about number of clusters per stratum into a data.frame

}}
\examples{
\dontrun{
## In this script we will create 5km resolution pixellated grid over Kenya, 
## and generate tables of estimated (both target and general) population 
## totals at the area (e.g. Admin-1) and subarea (e.g. Admin-2) levels. Then 
## we will use that to simulate populations and associated surveys of these

# download Kenya GADM shapefiles from SUMMERdata github repository
githubURL <- paste0("https://github.com/paigejo/SUMMERdata/blob/main/data/", 
                    "kenyaMaps.rda?raw=true")
tempDirectory = "~/"
mapsFilename = paste0(tempDirectory, "/kenyaMaps.rda")
if(!file.exists(mapsFilename)) {
  download.file(githubURL,mapsFilename)
}

# load it in
# out = load(mapsFilename)
out = load(url(githubURL))
out
adm1@data$NAME_1 = as.character(adm1@data$NAME_1)
adm1@data$NAME_1[adm1@data$NAME_1 == "Trans Nzoia"] = "Trans-Nzoia"
adm1@data$NAME_1[adm1@data$NAME_1 == "Elgeyo-Marakwet"] = "Elgeyo Marakwet"
adm2@data$NAME_1 = as.character(adm2@data$NAME_1)
adm2@data$NAME_1[adm2@data$NAME_1 == "Trans Nzoia"] = "Trans-Nzoia"
adm2@data$NAME_1[adm2@data$NAME_1 == "Elgeyo-Marakwet"] = "Elgeyo Marakwet"

# some Admin-2 areas have the same name
adm2@data$NAME_2 = as.character(adm2@data$NAME_2)
adm2@data$NAME_2[(adm2@data$NAME_1 == "Bungoma") & 
                   (adm2@data$NAME_2 == "Lugari")] = "Lugari, Bungoma"
adm2@data$NAME_2[(adm2@data$NAME_1 == "Kakamega") & 
                   (adm2@data$NAME_2 == "Lugari")] = "Lugari, Kakamega"
adm2@data$NAME_2[(adm2@data$NAME_1 == "Meru") & 
                   (adm2@data$NAME_2 == "Igembe South")] = "Igembe South, Meru"
adm2@data$NAME_2[(adm2@data$NAME_1 == "Tharaka-Nithi") & 
                   (adm2@data$NAME_2 == "Igembe South")] = "Igembe South, Tharaka-Nithi"

# The spatial area of unknown 8 is so small, it causes problems unless its removed or 
# unioned with another subarea. Union it with neighboring Kakeguria:
newadm2 = adm2
unknown8I = which(newadm2$NAME_2 == "unknown 8")
newadm2$NAME_2[newadm2$NAME_2 \%in\% c("unknown 8", "Kapenguria")] <- 
  "Kapenguria + unknown 8"
admin2.IDs <- newadm2$NAME_2

newadm2@data = cbind(newadm2@data, NAME_2OLD = newadm2@data$NAME_2)
newadm2@data$NAME_2OLD = newadm2@data$NAME_2
newadm2@data$NAME_2 = admin2.IDs
newadm2$NAME_2 = admin2.IDs
temp <- terra::aggregate(as(newadm2, "SpatVector"), by="NAME_2")

library(sf)
temp <- sf::st_as_sf(temp)
temp <- sf::as_Spatial(temp)

tempData = newadm2@data[-unknown8I,]
tempData = tempData[order(tempData$NAME_2),]
newadm2 <- SpatialPolygonsDataFrame(temp, tempData, match.ID = F)
adm2 = newadm2

# download 2014 Kenya population density TIF file

githubURL <- paste0("https://github.com/paigejo/SUMMERdata/blob/main/data/", 
                    "Kenya2014Pop/worldpop_total_1y_2014_00_00.tif?raw=true")
popTIFFilename = paste0(tempDirectory, "/worldpop_total_1y_2014_00_00.tif")
if(!file.exists(popTIFFilename)) {
  download.file(githubURL,popTIFFilename)
}

# load it in
pop = terra::rast(popTIFFilename)

ver = terra::gdal(lib="proj")
PROJ6 <- as.numeric(substr(ver, 1, 1)) >= 6

# from lon/lat coords to easting/northing
if(!PROJ6) {
  crs(pop) = "+proj=longlat"
} else {
  crs(pop) = "EPSG:4326"
}

eastLim = c(-110.6405, 832.4544)
northLim = c(-555.1739, 608.7130)

## Construct poppsubKenya, a table of urban/rural general population totals 
## in each subarea. Technically, this is not necessary since we can load in 
## poppsubKenya via data(kenyaPopulationData). First, we will need to calculate 
## the areas in km^2 of the areas and subareas

# use Lambert equal area projection of areas (Admin-1) and subareas (Admin-2)
midLon = mean(adm1@bbox[1,])
midLat = mean(adm1@bbox[2,])
p4s = paste0("+proj=laea +x_0=0 +y_0=0 +lon_0=", midLon, 
             " +lat_0=", midLat, " +units=km")

adm1_sf = st_as_sf(adm1)
adm1proj_sf = st_transform(adm1_sf, p4s)
adm1proj = as(adm1proj_sf, "Spatial")

adm2_sf = st_as_sf(adm2)
adm2proj_sf = st_transform(adm2_sf, p4s)
adm2proj = as(adm2proj_sf, "Spatial")

# now calculate spatial area in km^2
admin1Areas = as.numeric(st_area(adm1proj_sf))
admin2Areas = as.numeric(st_area(adm2proj_sf))

areapaKenya = data.frame(area=adm1proj@data$NAME_1, spatialArea=admin1Areas)
areapsubKenya = data.frame(area=adm2proj@data$NAME_1, subarea=adm2proj@data$NAME_2, 
                           spatialArea=admin2Areas)

# Calculate general population totals at the subarea (Admin-2) x urban/rural 
# level and using 1km resolution population grid. Assign urbanicity by 
# thresholding population density based on estimated proportion population 
# urban/rural, making sure total area (Admin-1) urban/rural populations in 
# each area matches poppaKenya.

# NOTE: the following function will typically take ~15-20 minutes. Can speed up 
#       by setting kmRes to be higher, but we recommend fine resolution for 
#       this step, since it only needs to be done once.
system.time(poppsubKenya <- getPoppsub(
  kmRes=1, pop=pop, domainMapDat=adm0,
  eastLim=eastLim, northLim=northLim, mapProjection=projKenya,
  poppa = poppaKenya, areapa=areapaKenya, areapsub=areapsubKenya, 
  areaMapDat=adm1, subareaMapDat=adm2, 
  areaNameVar = "NAME_1", subareaNameVar="NAME_2"))

# Now generate a general population integration table at 5km resolution, 
# based on subarea (Admin-2) x urban/rural population totals. This takes 
# ~1 minute
system.time(popMatKenya <- makePopIntegrationTab(
  kmRes=5, pop=pop, domainMapDat=adm0,
  eastLim=eastLim, northLim=northLim, mapProjection=projKenya,
  poppa = poppaKenya, poppsub=poppsubKenya, 
  areaMapDat = adm1, subareaMapDat = adm2,
  areaNameVar = "NAME_1", subareaNameVar="NAME_2"))

## Adjust popMat to be target (neonatal) rather than general population 
## density. First create the target population frame
## (these numbers are based on IPUMS microcensus data)
mothersPerHouseholdUrb = 0.3497151
childrenPerMotherUrb = 1.295917
mothersPerHouseholdRur = 0.4787696
childrenPerMotherRur = 1.455222
targetPopPerStratumUrban = easpaKenya$HHUrb * mothersPerHouseholdUrb * 
  childrenPerMotherUrb
targetPopPerStratumRural = easpaKenya$HHRur * mothersPerHouseholdRur * 
  childrenPerMotherRur
easpaKenyaNeonatal = easpaKenya
easpaKenyaNeonatal$popUrb = targetPopPerStratumUrban
easpaKenyaNeonatal$popRur = targetPopPerStratumRural
easpaKenyaNeonatal$popTotal = easpaKenyaNeonatal$popUrb + 
  easpaKenyaNeonatal$popRur
easpaKenyaNeonatal$pctUrb = 100 * easpaKenyaNeonatal$popUrb / 
  easpaKenyaNeonatal$popTotal
easpaKenyaNeonatal$pctTotal = 
  100 * easpaKenyaNeonatal$popTotal / sum(easpaKenyaNeonatal$popTotal)

# Generate the target population density by scaling the current 
# population density grid at the Admin1 x urban/rural level
popMatKenyaNeonatal = adjustPopMat(popMatKenya, easpaKenyaNeonatal)

# Generate neonatal population table from the neonatal population integration 
# matrix. This is technically not necessary for population simulation purposes, 
# but is here for illustrative purposes
poppsubKenyaNeonatal = poppRegionFromPopMat(popMatKenyaNeonatal, 
                                            popMatKenyaNeonatal$subarea)
poppsubKenyaNeonatal = 
  cbind(subarea=poppsubKenyaNeonatal$region, 
        area=adm2@data$NAME_1[match(poppsubKenyaNeonatal$region, adm2@data$NAME_2)], 
        poppsubKenyaNeonatal[,-1])
print(head(poppsubKenyaNeonatal))

## Now we're ready to simulate neonatal populations along with neonatal 
## mortality risks and prevalences

# use the following model to simulate the neonatal population based roughly 
# on Paige et al. (2020) neonatal mortality modeling for Kenya.
beta0=-2.9 # intercept
gamma=-1 # urban effect
rho=(1/3)^2 # spatial variance
effRange = 400 # effective spatial range in km
sigmaEpsilon=sqrt(1/2.5) # cluster (nugget) effect standard deviation

# Run a simulation! This produces multiple dense nEA x nsim and nPixel x nsim 
# matrices. In the future sparse matrices and chunk by chunk computations 
# may be incorporated.
simPop = simPopSPDE(nsim=1, easpa=easpaKenyaNeonatal, 
                    popMat=popMatKenya, targetPopMat=popMatKenyaNeonatal, 
                    poppsub=poppsubKenya, spdeMesh=kenyaMesh, 
                    margVar=rho, sigmaEpsilon=sigmaEpsilon, 
                    gamma=gamma, effRange=effRange, beta0=beta0, 
                    seed=12, inla.seed=12, nHHSampled=25, 
                    stratifyByUrban=TRUE, subareaLevel=TRUE, 
                    doFineScaleRisk=TRUE, doSmoothRisk=TRUE, 
                    min1PerSubarea=TRUE)

# get average absolute percent error relative to fine scale prevalence at Admin-2 level
tempDat = simPop$subareaPop$aggregationResults[c("region", "pFineScalePrevalence", 
                                                  "pFineScaleRisk", "pSmoothRisk")]
100*mean(abs(tempDat$pFineScalePrevalence - tempDat$pFineScaleRisk) / 
           tempDat$pFineScalePrevalence)
100*mean(abs(tempDat$pFineScalePrevalence - tempDat$pSmoothRisk) / 
           tempDat$pFineScalePrevalence)
100*mean(abs(tempDat$pFineScaleRisk - tempDat$pSmoothRisk) / 
           tempDat$pFineScalePrevalence)

# verify number of EAs per area and subarea
cbind(aggregate(simPop$eaPop$eaSamples[,1], by=list(area=popMatKenya$area), FUN=sum), 
      trueNumEAs=easpaKenya$EATotal[order(easpaKenya$area)])
aggregate(simPop$eaPop$eaSamples[,1], by=list(area=popMatKenya$subarea), FUN=sum)

## generate a survey assuming 1 target population member per household from the 
## simulated population
thisEApop = simPop$eaPop$eaDatList[1]

## get associated HH level population information
thisHHpop = getHHpop(thisEApop, fixPopPerHH=NULL)

## simulate a survey of .1\% of the EAs, with 25 households per EA
tempClustpa = easpaKenya[,1:7]
tempClustpa$EAUrb = round(tempClustpa$EAUrb * .01)
tempClustpa$EARur = round(tempClustpa$EARur * .01)
tempClustpa$EATotal = tempClustpa$EAUrb + tempClustpa$EARur
tempClustpa$HHUrb = tempClustpa$EAUrb * 25
tempClustpa$HHRur = tempClustpa$EARur * 25
tempClustpa$HHTotal = tempClustpa$HHUrb + tempClustpa$HHRur
tempClustpa

## sample DHS-like survey for this population and design
## first based on your desired survey design
survs = sampleClusterSurveys(1, thisHHpop, clustpaList=list(tempClustpa))
surv = survs[[1]]

## extract the actual number of clusters sampled at Admin1 level from the survey
getClustpaFromSurvey(surv)

## Now get the info at the Admin2 level
getClustpaFromSurvey(surv, stratName="subarea")
}
}
\seealso{
\code{\link{simPopCustom}}, \code{\link{simPopSPDE}}, \code{\link{makePopIntegrationTab}}, \code{\link{adjustPopMat}}, \code{\link{simSPDE}}.
}
\author{
John Paige
}
